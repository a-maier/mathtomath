#!/usr/bin/perl
# - input hinting (please enter ...)
# - run time including modules properly?
# - heuristic determination of input format (keep dreaming...)
# - custom options
# - fix multiple output formats
# - tests
use 5.10.1;
use warnings;
use strict;
use Data::Dump;
use Expression;
use Getopt::Long;
use Printer::Printer;

my $version;
my $version_number=0.0;

my $help;
my $help_text='TODO';

our $verbose;
our $strict;

my @in_formats;
my @out_formats=();

my ($parser,$tree);

sub get_formats;
sub print_expression;

GetOptions( 'informat|if=s' => \$in_formats[0],
	    'outformats|of=s' => \@out_formats,
	    'strict!' => \$strict,
	    'verbose!'=> \$verbose,
	    'help|?'=> \$help,
	    'version'=> \$version
    );
@out_formats=('Generic') unless @out_formats;
@out_formats=(split /,/,join(',',@out_formats));
@out_formats = map {$_.='_out';ucfirst} @out_formats;
$in_format=ucfirst $in_format;

if($version){
    say 'mathtomath version $version_number';
    exit;
}

if($help){
    say $help_text;
    exit;
}


{
    local $/=undef;
    $_=<>;
}

#try to determine input format if not given explicitely
@input_formats = get_formats unless @input_formats;

# we decide on our formats at run time,
# so we require require and don't use use
foreach my $out_format (@out_formats){
    eval(require "Printer/$out_format.pm");
}



eval(require "Parser/$in_format.pm" );

foreach my $format (@in_formats){
    #try to parse syntax tree
    $parser=$format->new;
    if($tree=$parser->parse($_)){
	#we found a working format
	print_expression($tree);
	exit(0);
    };
}


    
#create output in the desired format
foreach my $out_format (@out_formats){
    dd $tree;
    my $printer=${out_format}->new;
    my $out_str=$printer->to_string($tree);
    say $out_str;
}

sub get_formats{
    opendir( 
}
