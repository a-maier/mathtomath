/* Grammar for FORM */
%{
#use Data::Dump;
%}

%token NUMBER
%token POSYMBOL		/* plain old usual symbols */
%token FORMSYMBOL	/* special FORM symbols: [...] */

%left ','
%nonassoc '='
%left '+' '-'
%left '*' '/'
%left '^'
%nonassoc '.'

%%

input: /* empty */
       | term	
;

term:	symbol
	| number
	| equal
	| sum | diff | product | quot | exp | sp
	| bracket
	| function | list | listelement
	| spattern | cpattern
	| coefficient
;

symbol:	posymbol	
	| formsymbol
;

posymbol: POSYMBOL	{Node->new($_[1],'symbol')}
;

formsymbol: FORMSYMBOL	{Node->new($_[1],'symbol')}
;

number: NUMBER 	{Node->new($_[1],'number')}
;

equal:		term '=' term	{Node->new($_[2],'equal',$_[1],$_[3])}
;


sum:		'+' term			{Node->new($_[1],'sum',$_[2])}
		| term '+' term 		{Node->new($_[2],'sum',$_[1],$_[3])}
;

diff:		'-' term			{Node->new($_[1],'diff',$_[2])}
		| term '-' term			{Node->new($_[2],'diff',$_[1],$_[3])}
;

product:	term '*' term			{Node->new($_[2],'product',$_[1],$_[3])}
;

quot:		term '/' term			{Node->new($_[2],'quot',$_[1],$_[3])}
;

exp:		term '^' term			{Node->new($_[2],'quot',$_[1],$_[3])}
;

sp:		term '.' term			{Node->new($_[2],'sp',$_[1],$_[3])}
;

bracket: '(' term ')'	{Node->new($_[1],'bracket',$_[2])}
;


/* now comes the sick part of FORM syntax */
function:	symbol '(' term ')'		{Node->new($_[1],'function',$_[3])}
 	  	| symbol '(' fsequence ')'	{Node->new($_[1],'function',$_[3])}
 	  	| symbol '(' mpattern ')'	{Node->new($_[1],'function',$_[3])}
;

list:		 '{' lsequence '}'		{Node->new($_[1],'list',$_[2])}
;

/* sequences work differently for functions and for sets;
   this is for functions:
   there can be as many ',' as we want, but the last part _has_
   to be a term
   consecutive ',' count as zero: e.g f(,,1,,2)=f(0,0,1,0,2)
*/
fsequence: ',' term {Node->new($_[1],'sequence',0,$_[2])}
	   | fsequence ',' term {Node->new($_[2],'sequence',$_[1],$_[3])}
	   | ',' fsequence {Node->new($_[1],'sequence',0,$_[2])}
;

/*  list sequence: basically, can have arbitrary many ',' in any position 
    each ',' corresponds to a ' ' i.e. has no meaning other than separating list entries (afaik)
    we _will_ have to replace whitespaces with ',' in a kind of preprocessor (in sub parse?) inside
    curly brackets for this to work properly 
*/

lsequence: ',' term {Node->new($_[1],'sequence',$_[2])}
	   | lsequence ',' term {Node->new($_[2],'sequence',$_[1],$_[3])}
;

spattern: symbol '?' {Node->new($_[2],'single_pattern',$_[1])}
;

mpattern: '?' symbol {Node->new($_[1],'multi_pattern',$_[2])}
;


/* array indices */
listelement: list formsymbol {Node->new('','listelement',$_[1],$_[2])}
;

/* not in list */
not: '!' list {Node->new('!','not',$_[2])}
;

/* conditional patterns */
cpattern: spattern list {Node->new('','cond_pattern',$_[1], $_[2])}
	  | spattern listelement {Node->new('','cond_pattern',$_[1], $_[2])}
	  | spattern not {Node->new('','cond_pattern',$_[1], $_[2])}
;

/* coefficient of an expression */
#coefficient: symbol '[' term ']'	{Node->new('[','coefficient',$_[1], $_[3])}
#;
%%

my %pair=(
   '[' => ']',
   '`' => "'",
   "'" => "'",
);

#find the matching closing bracket for $_[1] in $_[0]
sub find_matching_bracket{
    my $text=shift;
    my $bracket=shift;
    my $anti_bracket=$pair{$bracket};
    defined $anti_bracket or die "'$bracket' is not a bracket";
    my $count=1;
    my $i=1;
    for(;$i<length($text);++$i){
    	   if(substr($text,$i,1) eq $bracket){++$count; }
    	   elsif(substr($text,$i,1) eq $anti_bracket){--$count; }
	   $count or last;
    }
    return undef if $i==length($text);
    return $i;   
}

sub _error {
    if(exists $_[0]->YYData->{ERRMSG}) {
	print $_[0]->YYData->{ERRMSG};
        delete $_[0]->YYData->{ERRMSG};
        return;
    };	
    print "Syntax error.\n";
}

sub _lexer {
    my $parser =shift;
    
    return('',undef) unless $parser->YYData->{INPUT};
    #TODO: convert to internal format (i.g. d_ -> delta)
    for ($parser->YYData->{INPUT}) {
	return('NUMBER',$1) if s/^(\d+)//; 
	return('POSYMBOL',$1) if s/^([[:alpha:]]+_)//;
	if(/^([\['`])/){
		  my $end=find_matching_bracket($_,$1);
		  defined $end or die "Unmatched bracket";
		  my $symbol=substr($_,0,$end+1);
		  substr($_,0,$end+1)='';
		  return('FORMSYMBOL',$symbol);
	}
        return($1,$1) if s/^(.)//s;
    }
}

sub parse {
    my $self=shift;
    my $data=shift;
    for ($data){
	s/\s+//g;
	$self->YYData->{INPUT} = $_
    }
    $self->YYParse( yylex => \&_lexer, yyerror => \&_error );
}

