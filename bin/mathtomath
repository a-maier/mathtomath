#!/usr/bin/perl

=head1 NAME

mathtomath - Convert mathematical expressions between different formats

=head1 SYNOPSIS

B<mathtomath> [options] [input files]

=head1 DESCRIPTION

I<mathtomath> reads mathematical expressions from the input files
(or from STDIN if no files are specified) and displays the
corresponding expressions in one or more custom formats. 

Usually you will want to specify at least one output format
with the I<L</-outformat>> option - if you don't a default
output format will be chosen. It is also recommended (although
not mandatory) to specify the format of the input expressions
with the I<L</-informat>> option.

=cut

use 5.10.1;
use warnings;
use strict;
use Math::ToMath qw(:all);
use Data::Dump;
use Getopt::Long;
use Pod::Usage;
use Math::ToMath::Options;
use File::Path qw(make_path);

my $version;

my $help;
my $tree;

my $quiet;
my $verbose;
my $strict;

my $in_format;
my @out_formats;
my $expression;
my $raw_cl_options;
my %cl_options;

=head1 OPTIONS

=over 2

=item B<-?>, B<-help>        

Display a short help message and exit

=item B<-expression>, B<-e> I<expression> 

Use I<expression> as input expression instead of reading from
input files or standard input.

=item B<-informat>, B<-if> I<format> 

Specify the format of the input expressions. The currently supported
formats are B<FORM>, B<LaTeX>, B<Mathematica> and a default format
(B<generic>). Format names are case-insensitive. If no input format is
specified, B<mathtomath> will try all available formats in a random
order. This can lead to ambiguities. (have a look at the L</EXAMPLES>)

=item B<-outformat>, B<-of> I<outformat1[,outformat2,...]> 

Specify one or more formats to which the input expressions
will be converted. The currently supported formats are
B<FORM>, B<LaTeX>, B<Mathematica> and a default format
(B<generic>). Format names are case-insensitive.

=item B<-o>, B<-options> I<option1=value1[,option2=value2,...]>

B<TODO> Specify options for the formatting of the output. The
supported options depend on the chosen output formats. See
the manual B<TODO:Link> for more details

=item B<-quiet>

B<TODO> Suppress output messages.

=item B<-strict>

B<TODO> Fail if there are ambiguities in the conversion. This
is actually quite common and without this option I<mathtomath>
will still try do construct a somewhat sensible output expression.

=item B<-verbose>

Explain what is happening.

=item B<-version>

Display version number and exits

=back

=cut

GetOptions( 'informat|if=s' => \$in_format,
	    'outformats|of=s' => \@out_formats,
	    'expression|e=s' => \$expression,
	    'options|o=s' => \$raw_cl_options,
	    'strict!' => \$strict,
	    'quiet!' => \$quiet,
	    'verbose!'=> \$verbose,
	    'h|help|?'=> \$help,
	    'version'=> \$version
    );

if($version){
    say 'mathtomath version ' . Math::ToMath->VERSION;
    exit;
}

if ($help) {
    pod2usage(-verbose => 1);
}

if($raw_cl_options){
    my $parser=Math::ToMath::Options->new();
    %cl_options = %{$parser->parse($raw_cl_options)};
}

@out_formats = ('Generic') unless @out_formats;
@out_formats = map ucfirst(lc($_)),
               map {split /,/, $_} @out_formats;

$in_format=ucfirst lc $in_format if $in_format;

# we decide on our formats at run time,
# so we require require and don't use use?
foreach my $out_format (@out_formats){
    $out_format = "Math::ToMath::Printer::$out_format";
    eval "require $out_format; 1;";
}

if(!defined $expression){
    local $/=undef;
    $expression=<>;
}

#parse syntax tree
if($in_format){
    my $parser_class = Parser->get_parser($in_format);
    my $parser=$parser_class->new;
    say "Parsing $in_format expression" if $verbose;
    $tree=$parser->parse($expression) or die "Failed to parse expression!";
}
else{
    #no input format is given, try all possibilities
    say "Trying to guess input format" if $verbose;
    my @parser_classes = Parser->get_parsers();
    foreach my $parser_class (@parser_classes){
	my $parser=$parser_class->new;
        my $in_format = $parser_class;
        $in_format =~ s/^Math::ToMath::Parser:://;
	#as soon as we can parse the input successfully in one format
	# we claim to have won
	if ($tree=$parser->parse($expression)) {
	    say "Input format: $in_format" if $verbose;
	    last;
	}
    }
    $tree or die "No suitable input format found for expression"
}

#create output in the desired format
foreach my $out_format (@out_formats){
    #dd $tree;
    my $printer=gen_printer($out_format,options => \%cl_options);
    say "Output format: ",$printer->format unless $quiet;
    say $printer->convert($tree);
}


#get options or rules for the given format from the corresponding configuration file
sub get_format_config{
    my $format=shift;
    my $type=shift;
    my $parser=Math::ToMath::Options->new();
    my $path="$ENV{HOME}/.mathtomath/$format/";
    if(-e "$path$type"){
	open(my $in,'<',"$path$type") or die "Failed to open $path$type: $!";
	local $/;
	my $options=$parser->parse(<$in>);
	$options // die "Failed to parse $path$type for format $format";
	close $in;
	return %$options;
    }
    #configuration file does not exists, try to create it
    say "Creating configuration file $path$type";
    make_path($path);
    open(my $out,'>',"$path$type") or die "Failed to create $path$type: $!";
    close $out;
    return ();
}

#generate a printer of the given class and set options and rules according to
# configuration files and command line options
sub gen_printer{
    my $parser_class = shift;
    my $parser=$parser_class->new;
    my %override=@_;#
    my $format=$parser_class;
    $format =~ s/^Math::ToMath::Printer:://;
    #default options/rules from configuration files
    my %options=get_format_config($format,"options");
    #additional options (e.g. from command line)
    @options{keys %{$override{options}}}=values %{$override{options}};
    $parser->options(%options);

    return $parser;
}

=head1 EXAMPLES

Convert the formula for the area of a square from B<Mathematica> convention
to B<LaTeX>:

  mathtomath -if Mathematica -of LaTeX -e 'Pi*r^2'

Not specifying an input format can lead to undefined results.
This may in principle result to C<(v.v)^2>, but also to C<v.(v^2)>:

  mathtomath -e 'v.v^2'

This reads expressions from a file and adds line breaks after
approximately 40 characters to the B<LaTeX> output:

  mathtomath -if Mathematica -of Latex -o 'line_length=40' file_with_long_expressions

=head1 FILES

=over 2

=item B<.mathtomath> Directory containing configuration files

=back

=head1 BUGS

Too many to list. Please report bugs to B<TODO>.

=head1 SEE ALSO

B<TODO> manual, format modules, github, cpan

L<https://github.com/a-maier/mathtomath>

=head1 AUTHOR

B<TODO> we

=cut

